---
title: "DHARMa - Residual Diagnostics for HierArchical (Multi-level / Mixed) Regession Models"
author: "Florian Hartig"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A demo of the package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8](inputenc)
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=5, warning=FALSE, message=FALSE, cache = F)
```

***Summary**: The DHARMa package creates easily interpretable, residuals for generalized linear mixed models that are standardized to values between 0 and 1. This is achieved by a simulation-based approach, similar to the Bayesian p-value or the parametric bootstrap: 1) simulate new data from the fitted model 2) calculate the cummulative empirical density function 3) residual is the value of the empirical density function at the value of the observed data.*  

### Installing the package

If you haven't installed the package yet, run

```{r, eval = F}
library(devtools)
install_url("https://dl.dropboxusercontent.com/s/hlg8j0d85ftijem/DHARMa_0.0.0.9000.tar.gz", dependencies = T)

```

### Loading the package

```{r}
set.seed(1)
library(DHARMa)
citation("DHARMa")
```

# Workflow in DHARMa

```{r}
# Some test data
testData = createData(sampleSize = 2000, overdispersion = 2, family = poisson())

# a fitted lme4 model
library(lme4)
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) , family = "poisson", data = testData)

# The function simulateResiduals() in DHARMa creats standardized residuals
simulationOutput <- simulateResiduals(fittedModel = fittedModel)

# You can plot the residuals with the plotSimulatedResiduals() function
plotSimulatedResiduals(simulationOutput = simulationOutput)
```

# Interpretation of the residual plots

The above exampel shows a misspecified model. The reason is that we created data with overdispersion, but the fitted model does not include overdispersion. For a correctly specified model, one would expect

* a flat histogram of the scaled residuals
* no pattern against the fitted value

## Example of a correctly specified model 

For comparison, also "standard residual plots" (deviance, pearso and raw) are shown

```{r}
testData = createData(sampleSize = 250, intercept = 0, overdispersion = 0, family = poisson(), randomEffectVariance = 0)
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) , family = "poisson", data = testData)

plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)
```

## Diagnosing overdispersion or underdispersion problems 

### Overdispersion

This is how **overdispersion** looks like 

```{r}
testData = createData(sampleSize = 500, overdispersion = 2, family = poisson())
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) , family = "poisson", data = testData)

plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)
```

### Overdispersion, corrected

Now if we fit the overdispersed example with a model that includes overdispersion everything is fine again 

```{r}
testData = createData(sampleSize = 500, overdispersion = 2, family = poisson())
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) + (1|ID) , family = "poisson", data = testData)

plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)
```

### Underdispersion



```{r}
testData = createData(sampleSize = 500, intercept=0, fixedEffects = 2, overdispersion = 0, family = poisson(), roundPoissonVariance = 0.001, randomEffectVariance = 0)
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) , family = "poisson", data = testData)

summary(fittedModel)

plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)
```


## Diagnosing heteroscedasticity

Also binomial or poisson models can show heteroscedasticity, meaning that the dispersion parameter changes with some other parameter. Here an example where we create such data 

```{r}
testData = createData(sampleSize = 500, intercept = 0, overdispersion = function(x){return(rnorm(length(x), sd = 2*abs(x)))}, family = poisson(), randomEffectVariance = 0)
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group), family = "poisson", data = testData)

plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)
```

Adding a simple overdispersion correct will not completely remove the problem. The qq plot looks better, but there is still a pattern in the residuals 

```{r}
testData = createData(sampleSize = 500, intercept = 0, overdispersion = function(x){return(rnorm(length(x), sd = 2*abs(x)))}, family = poisson(), randomEffectVariance = 0)
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) + (1|ID), family = "poisson", data = testData)

plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)

```

## Diagnosing more complicated model misspecification such as missing predictors or quadratic effects 

You don't have to rely on the overall qq and residual against predicted plots that are provided. To diagnose model misspecification (e.g. missing predictor), or spatial or temporal autorcorrelation it is *highly recommeded* to plot residuals against (where possible)

* all predictors
* space
* time

For that purpose, you can retrieve the residuals via 

```{r, eval = F}
simulationOutput$scaledResiduals
```

Note again that the residual values are scaled between 0 and 1. If you plot the residuals against predictors, space or time, the resulting plots should not only show no systematic dependency of those residuals on the covariates, but they should also again be flat for each fixed situation. That means that if you have, for example, a categorical predictor: treatment / control, the distribution of residuals for each predictor alone should be flat as well. 

Here an example with a missing quadratic effect in the model and 2 predictors

```{r}
testData = createData(sampleSize = 500, intercept = 1, fixedEffects = c(1,2), overdispersion = 0, family = poisson(), quadraticFixedEffects = c(-3,0))
fittedModel <- glmer(observedResponse ~ Environment1 + Environment2 + (1|group) , family = "poisson", data = testData)
simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotConcentionalResiduals(fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)

```

Difficult to see with the overall pattern, but it becomes clear if we plot against the environment

```{r}
par(mfrow = c(1,2))
plotResiduals(testData$Environment1,  simulationOutput$scaledResiduals)
plotResiduals(testData$Environment2,  simulationOutput$scaledResiduals)
```


# Further examples


Works exactly as before

```{r}
testData = createData(sampleSize = 2000, overdispersion = 2, family = binomial())
fittedModel <- glmer(observedResponse ~ Environment1 + (1|group) , family = "binomial", data = testData)
summary(fittedModel)
plotConcentionalResiduals(fittedModel)

simulationOutput <- simulateResiduals(fittedModel = fittedModel)
plotSimulatedResiduals(simulationOutput = simulationOutput)

```





